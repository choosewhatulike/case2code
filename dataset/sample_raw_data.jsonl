{"id": "d0acde15-8e84-33d1-9bcb-9ddc36f781d1_0_0", "content": "def n_natural(num):\n    return n * (n + 1) / 2\n", "import_code": []}
{"id": "8edc5477-63e0-3d26-b82c-8787d9340f36_3_0", "content": "def count_score(cards):\n    score = 0\n    a_count = 0\n    for card in cards:\n        if str(card['rank']).isdigit():\n            score += card['rank']\n        elif card['rank'] == 'A':\n            score += 11\n            a_count += 1\n        else:\n            score += 10\n    if score > 21 and a_count != 0:\n        while a_count != 0:\n            score -= 10\n            a_count -= 1\n    return score\n", "import_code": []}
{"id": "d93888a2-9ff5-3199-99ae-3e682f646360_5_0", "content": "def validate_two(password):\n    return basic_validation(password) and only_two_adjacent(password)\n", "import_code": []}
{"id": "5ae10138-890a-3b1e-b567-9a06280f4b79_1_0", "content": "def r_c(j):\n    return dr * (j + 0.5)\n", "import_code": []}
{"id": "4cd3966f-5c0e-3deb-b224-0020cbf8a1c6_0_0", "content": "def oddEven(list):\n    result = []\n    result2 = []\n    for i in range(1, len(list)):\n        if i % 2 == 0:\n            result.append(list[i])\n        else:\n            result2.append(list[i])\n    merged = result + result2\n    return merged\n", "import_code": []}
{"id": "695d5b75-d8f8-39bb-a244-35a900cae958_0_0", "content": "def myAtoi(s):\n    sign, base, i = 1, 0, 0\n    if s == '' or s == ' ':\n        return 0\n    while s[i] == ' ':\n        i += 1\n    if s[i] == '-' or s[i] == '+':\n        sign = 1 - 2 * (s[i] == '-')\n        i += 1\n    while i < len(s) and s[i] >= '0' and s[i] <= '9':\n        if base > 214748364 or base == 214748364 and int(s[i]) - 0 > 7:\n            if sign == 1:\n                return 2147483647\n            else:\n                return -2147483648\n        base = 10 * base + (int(s[i]) - 0)\n        i += 1\n    return base * sign\n", "import_code": []}
{"id": "afa979da-006e-3d41-9208-4a1b5fad718e_2_0", "content": "def _complete_combinations(board, combinations, player, s=2, warning=None):\n    \"\"\"Returns a set of cells that can be marked\n    to complete the combinations (lines or forks).\n    Calling this function with player=opponent\n    returns the combinations that opponent can complete\n    in the next turn - so these combinations can be blocked.\n    :param board: list\n    :param combinations: set of tuples\n    :param player: string\n    :param s: int\n        a critical length of marks set\n    :param warning: set\n        don't provoke the opponent\n        into marking these positions\n    :return: set\n    \"\"\"\n    opponent = 'o' if player == 'x' else 'x'\n    comp_comb = set()\n    for comb in combinations:\n        marks = set(board[index] for index in comb)\n        if len(marks) == s and player in marks and opponent not in marks:\n            if s == 3 and warning:\n                marks = _handle_warning(marks, warning)\n            comp_comb.update(marks - {'x', 'o'})\n    return comp_comb\n", "import_code": []}
{"id": "45732755-03f8-3329-88bc-c8dd5c7ecb9b_8_0", "content": "def change(n, f, t):\n    if str(f) not in str(n):\n        return error\n    return int(str(n).replace(str(f), str(t)))\n    \"\"\"\n    pos=[0]\n    i=0\n    while f in n[pos[i]+len(f):]:\n        pos.append(n[pos[i]+len(f):].index(f))\n        i+=1\n    for i in pos:\n        n=n[:pos]+t+n[pos+len(f):]\n    return sign*int(n)\n    \"\"\"\n", "import_code": []}
{"id": "9f4b5068-a7be-3f26-9c57-4588055b7d89_12_0", "content": "def filter_annotations_with_brackets(text):\n    \"\"\"Removes annotations with some brackets.\n\n    Even nested e.g. _When_(sth(nested bracket(nested in nested))).\n    \"\"\"\n    text = re.sub('(?<=,|\\\\()\\\\s*\\\\b__(in|out)\\\\w+\\\\s*\\\\([^)]*\\\\)', '', text)\n    x = 0\n    found = re.search(\n        '\\\\b_{1,2}[A-Z]\\\\w*_{1,2}\\\\b\\\\s*\\\\(.*?\\\\)(.*?\\\\)){%d}' % x, text,\n        flags=re.S)\n    if found is None:\n        return text\n    annot = re.escape(found.group(0))\n    while annot:\n        while annot.count('(') != annot.count(')'):\n            x = x + 1\n            found = re.search(\n                '\\\\b_{1,2}[A-Z]\\\\w*_\\\\b\\\\s*\\\\(.*?\\\\)(.*?\\\\)){%d}' % x, text,\n                flags=re.S)\n            if found is None:\n                return text\n            annot = re.escape(found.group(0))\n        text = re.sub(annot, '', text, count=1)\n        x = 0\n        found = re.search('\\\\b_{1,2}[A-Z]\\\\w*_\\\\b\\\\s*\\\\(.*?\\\\)(.*?\\\\)){%d}' %\n            x, text, flags=re.S)\n        if found is None:\n            return text\n        annot = re.escape(found.group(0))\n", "import_code": ["import re"]}
{"id": "4201bc88-9c9a-31d3-9d3b-f43256ceaef8_4_0", "content": "def shuffle(off, inc, moves):\n    for move in moves:\n        if move == 'deal into new stack':\n            inc *= -1\n            inc %= CARDS\n            off += inc\n            off %= CARDS\n        elif move.startswith('cut '):\n            n = int(move[4:])\n            off += inc * n\n            off %= CARDS\n        elif move.startswith('deal with increment '):\n            inv = pow(n % CARDS, CARDS - 2, CARDS)\n            inc *= inv\n            inc %= CARDS\n        else:\n            print('ERR:', move)\n    return off, inc\n", "import_code": []}
